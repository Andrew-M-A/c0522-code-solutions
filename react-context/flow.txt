From the ‘index.jsx’ file, the ‘App’ component is passed as an argument to the ‘render’ method of the ‘root’ object.  ‘App’ is called and the initial state is set with ‘user:null’, ‘isAuthorizing: true’, and ‘route’ being set to ‘sign-in’. ‘Render’ is then called and since ‘user: null’, ‘componentDidMount’ is called and the ‘hashchange’ event listener is added to the window. The ‘jwt’ token is then retrieved from localStorage and ‘setState’ is called, changing the value of ‘this.state.user’ and ‘this.state.isAuthorizing’

‘render’ is then called again but since ‘isAuthorizing’ is not null, ‘user’ and ‘route’ are destructured from ‘this.state’, ‘handleSignIn/Out’ are destructured from ‘this’, and all of those values are assigned to 'contextValue'. The ‘AppContext’ component is then returned with a value of ‘contextValue’, the ‘NavBar’ component is returned, and then the ‘PageContainer’ component, the home page is rendered and ‘window.location.hash’ is set to ‘’.
Before the ‘Home’ or ‘Auth’ components are called, a path is set to ‘’ or ‘sign-in/out', respectively… that’s why the user is able to refresh while signed in and still be on the home page

When the user types into the form inputs, the ‘handleChange’ method of the AuthForm class will destructure event target and create a ‘name’ and ’value’ property. handleChange will then ‘setState’ of AuthForm by assigning ‘value’ to the first element of an array ‘name’. AuthForm is then re-rendered with the input values. When the user clicks the ‘Log In’ button, ‘handleSubmit’ of AuthForm will be called and it will destructure the ‘action’ property from ‘this.props.’ If that value is ‘sign-up’, a ‘POST’ request is sent to the server with the users ‘username’ and ‘password.’ If the ’username’ and ‘password’ are valid, ‘password’ will be hashed by ‘argon2’, then (wink) a ’sql’ query will be created with the users ‘username’ and new ‘hashedPassword’ and be inserted into the database. Then (wink) a response is sent back to the client with a 201 (successful) status and the ‘user’ element of the ‘result.rows’ array.

If that value is ‘sign-in.’ Then ‘handleSubmit’ will create a new object ‘req’ in preparation of a ‘fetch’ request. A fetch request will then be sent to the server with two arguments, the first ‘/api/auth’ with the value of ‘action’ tacked onto the end and second, the ‘req’ object created right before. A ‘POST’ request is then sent to the server. If the username and password are valid, the user’s info (userId and hashedPassword) will then be queried from the database by their username. If the username is valid, ‘userID’ and ‘hashedPassword’ will be destructured from ‘user.’ After, the ‘verify’ method will be called with the ‘hashedPassword’ and the ‘password’ from the input as arguments. If they match, a ‘payload’ will be created with the users ‘userId’ and ‘username’ A signed token is then created with the payload. After, the token and the user payload are sent in an object back to the client. When that’s received, ‘handleSignIn’ is then called with the ‘result’ of the ‘fetch’ request. ‘user’ and ‘token’ are then destructured from ‘result.’ The ‘token’ is put into localStorage and ‘setState’ is reset with the value of ‘user’

When the user wants to sign out, ‘handleSignOut’ is called, localStorage is cleared, and ‘user’ is set to ‘null.’
‘render’ is called again but when ‘Navbar’ is returned this time, ‘href’ is returned as ‘sign-in/out’ and we land back on the login page
